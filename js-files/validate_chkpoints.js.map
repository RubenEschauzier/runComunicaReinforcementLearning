{"version":3,"file":"validate_chkpoints.js","sourceRoot":"","sources":["../validate_chkpoints.ts"],"names":[],"mappings":"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","sourcesContent":["import {BindingsStream, IBatchedTrainingExamples, ITrainEpisode, ITrainingExample} from \"@comunica/types\";\nimport {IAggregateValues, IRunningMoments} from \"@comunica/mediator-join-reinforcement-learning\";\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { updateRunningMoments } from \"./helper\";\n\nclass ValidateModelCheckpoints{\n    public engine: any;\n    public queries: string[];\n    public valQueries:string[];\n    public batchedTrainingExamples: IBatchedTrainingExamples;\n    public batchedValidationExamples: IBatchedTrainingExamples;\n    public runningMomentsExecutionTime: IRunningMoments;\n\n    public constructor(){\n        const QueryEngine = require('@comunica/query-sparql-file').QueryEngineFactory;\n        this.engine = new QueryEngine().create();\n        this.batchedTrainingExamples = {trainingExamples: new Map<string, ITrainingExample>, leafFeatures: {hiddenStates: [], memoryCell:[]}};\n        this.batchedValidationExamples = {trainingExamples: new Map<string, ITrainingExample>, leafFeatures: {hiddenStates: [], memoryCell:[]}};\n        this.queries=[];\n        this.valQueries=[];\n        this.runningMomentsExecutionTime = {indexes: [0], runningStats: new Map<number, IAggregateValues>()};\n        for (const index of this.runningMomentsExecutionTime.indexes){\n            const startPoint: IAggregateValues = {N: 0, mean: 0, std: 1, M2: 1}\n            this.runningMomentsExecutionTime.runningStats.set(index, startPoint);\n        }\n    }\n\n    public async executeWarmUpQuery(){\n        this.engine = await this.engine;\n        const nopStream = await this.engine.query('SELECT * WHERE {?x ?y ?z} LIMIT 1', {\"sources\":[\"output/dataset.nt\"]});\n    }\n\n    public async executeQueryValidation(query: string, sources:string[]): Promise<number[]>{\n        const startTime: number = this.getTimeSeconds();\n\n        // Execute and consume query\n        const bindingsStream: BindingsStream = await this.engine.queryBindings(query, {sources: sources});\n        const exeuctionTimes: number[] = await this.addListener(bindingsStream, startTime);\n\n\n        this.engine.disposeTrainEpisode();\n        this.engine.trainEpisode = {joinsMade: [], estimatedQValues: [], featureTensor: {hiddenStates:[], memoryCell:[]}, isEmpty:true};    \n        return exeuctionTimes;\n    }\n\n    public async loadWatDivQueries(queryDir: string, val:boolean){\n        const loadingComplete = new Promise<boolean> (async (resolve, reject) => {\n            try {\n                // Get the files as an array\n                const files = await fs.promises.readdir( queryDir );\n                for( const file of files ) {\n                    // Get the full paths\n                    const filePath = path.join( queryDir, file );    \n                    const data = fs.readFileSync(filePath,'utf8');\n                    if (val){\n                        this.valQueries.push(data);\n                    }\n                    else{\n                        this.queries.push(data);\n                    }\n                }\n                resolve(true); \n            }\n            catch( e ) {\n                console.error( \"Something went wrong.\", e );\n                reject();\n            }\n        });\n        return loadingComplete;\n    }\n\n    public addListener(bindingStream: BindingsStream, startTime: number): Promise<number[]>{\n        /**\n         * Function that consumes the binding stream, measures elapsed time, and updates the batchTrainEpisode\n         */\n        let numEntriesPassed: number = 0;\n        const finishedReading: Promise<number[]> = new Promise((resolve, reject) => {\n                bindingStream.on('data', (binding: any) => {\n                    numEntriesPassed += 1;\n                });\n\n                bindingStream.on('end', () => {\n                    const endTime: number = this.getTimeSeconds();\n                    const elapsed: number = endTime-startTime;\n                    const statsY: IAggregateValues = this.runningMomentsExecutionTime.runningStats.get(this.runningMomentsExecutionTime.indexes[0])!;\n                    const standardisedElapsed = (elapsed - statsY.mean) / statsY.std;\n                    resolve([elapsed, standardisedElapsed]);\n                });    \n        });\n        return finishedReading;\n    }\n    \n    public async awaitEngine(){\n        this.engine = await this.engine\n    }\n\n    public getTimeSeconds(){\n        const hrTime: number[] = process.hrtime();\n        const time: number = hrTime[0] + hrTime[1] / 1000000000;\n        return time\n    }\n\n    protected idxToKey(indexes: number[][]){\n        return indexes.flat().toString().replaceAll(',', '');\n    }\n}\n\n\nconst numSimVal = 5;\nconst validatorEngine = new ValidateModelCheckpoints();\n\nconst loadingValidation = validatorEngine.loadWatDivQueries('output/queries', true);\n// Find all chkpoints made during model training\nconst chkpointsFound = fs.readdirSync(path.join(__dirname,'../modelToValidate/'));\n// Sort the directories\nchkpointsFound.sort(function(a, b) {\n    return a.localeCompare(b, undefined, {\n      numeric: true,\n      sensitivity: 'base'\n    });\n});\nconst chkpointsFoundAbsolute = chkpointsFound.map(x=> path.join(__dirname, \"../modelToValidate/\", x));\n\nconst totalEpochTrainLoss: number[] = [];\nconst epochValLoss: number[] = [];\nconst epochValExecutionTime: number[] = [];\nconst epochValStdLoss: number[] = []\nconsole.log(`Number of validation query templates: ${validatorEngine.valQueries}`);\nloadingValidation.then(async ()=>{\n    let cleanedValidationQueries: string[][] = validatorEngine.valQueries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\n    await validatorEngine.executeWarmUpQuery();\n    let i = 1;\n    for (const chkpLocation of chkpointsFoundAbsolute){\n        console.log(`Checkpoint ${i}/${chkpointsFound.length+1}`)\n        await validatorEngine.engine.loadState(chkpLocation);\n        const templateExecutionTimes = [];\n        for (let i=0;i<cleanedValidationQueries.length;i++){\n            console.log(`Query Template ${i+1}/${cleanedValidationQueries.length}`);\n            let totalExecutionTimeTemplate = 0;\n            const querySubset: string[] = [... cleanedValidationQueries[i]];\n            querySubset.shift();\n            for (let j=0;j<querySubset.length;j++){\n                let successfulJoinExecutions: number = 0;\n                for (let k=0;k<numSimVal;k++){\n                    const executionTimes: number[] = await validatorEngine.executeQueryValidation('SELECT' + querySubset[j], [\"output/dataset.nt\"]);\n                    totalExecutionTimeTemplate += executionTimes[0];\n                }\n            }\n            const averageTemplateExecutionTime = totalExecutionTimeTemplate / (querySubset.length * numSimVal);\n            templateExecutionTimes.push(averageTemplateExecutionTime);\n        }\n        console.log(\"Average execution time per template\");\n        console.log(templateExecutionTimes)\n        fs.appendFileSync(\"validationResults/averageExecutionTimeTemplate.txt\", JSON.stringify(templateExecutionTimes) + \"\\n\");\n        i += 1;\n    }\n\n});\n\n\n// loadingTrain.then(async ()=>{\n//     let cleanedQueries: string[][] = validatorEngine.queries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\n//     await validatorEngine.executeQueryTrain('SELECT' + cleanedQueries[1][1], [\"output/dataset.nt\"], false);\n//     validatorEngine.cleanBatchTrainingExamples();\n\n//     for (let epoch=0;epoch<nEpochs; epoch++){\n//         let epochTrainLoss = [];\n//         for (let i=0;i<cleanedQueries.length;i++){\n//             console.log(`Query Template ${i+1}/${cleanedQueries.length}`);\n\n//             const querySubset: string[] = [... cleanedQueries[i]];\n//             querySubset.shift();\n\n//             for (let j=0;j<querySubset.length;j++){\n\n//                 let successfulJoinExecutions: number = 0;\n//                 for (let k=0;k<numSim;k++){\n//                     const foundJoins: boolean = await validatorEngine.executeQueryTrain('SELECT' + querySubset[j], [\"output/dataset.nt\"], true);\n//                     // Here we keep track if there are joins in the executed query, if not we log the query and don't train on it\n//                     // Does not work properly\n//                     successfulJoinExecutions += foundJoins ? 1 : 0;\n//                     if (!foundJoins){\n//                         let mapEntry = zeroJoinsFound.get('SELECT' + querySubset[j]);\n//                         if (mapEntry){\n//                             mapEntry += 1;\n//                         }\n//                         else{\n//                             zeroJoinsFound.set('SELECT' + querySubset[j], 1);\n//                         }\n//                     }\n//                 }\n//                 console.log(validatorEngine.batchedTrainingExamples);\n//                 if (successfulJoinExecutions>0){\n//                     epochTrainLoss.push(await validatorEngine.engine.trainModel(validatorEngine.batchedTrainingExamples));\n//                 }\n//                 validatorEngine.cleanBatchTrainingExamples();\n//             }\n//         }\n//         const avgLossTrain = epochTrainLoss.reduce((a, b) => a + b, 0) / epochTrainLoss.length;\n//         console.log(avgLossTrain);\n//         const [avgExecution, avgExecutionTemplate, stdExecutionTemplate, avgLoss, stdLoss] = await validatePerformance(validatorEngine.valQueries);\n//         console.log(`Epoch ${epoch+1}/${nEpochs}: Train Loss: ${avgLossTrain}, Validation Execution time: ${avgExecution}, Loss: ${avgLoss}, Std: ${stdLoss}`);\n\n//         // Checkpointing\n//         // const checkPointLocation = path.join(nextModelLocation + \"/chkp-\"+epoch);\n\n//         // fs.mkdir(checkPointLocation, (err)=>{\n//         //     if (err){\n//         //         return console.error(err);\n//         //     }\n//         // });\n\n//         // const epochStatisticsLocation = pathEpochInfos.map(x=>path.join(checkPointLocation, x));\n//         // console.log(epochStatisticsLocation)\n\n//         // totalEpochTrainLoss.push(avgLossTrain); epochValLoss.push(avgLoss); epochValExecutionTime.push(avgExecution); epochValStdLoss.push(stdLoss);    \n//         // writeEpochFiles(epochStatisticsLocation, [totalEpochTrainLoss, epochValLoss, epochValStdLoss, epochValExecutionTime], epoch);\n//     }\n//     fs.writeFileSync('log/skippedQueries.json', JSON.stringify([...zeroJoinsFound]) , 'utf-8'); \n//     validatorEngine.engine.saveModel(pathRunningMoments+\"runningMomentsFeatures\"+1+\".json\");  \n// });\n"]}