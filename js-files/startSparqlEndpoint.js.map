{"version":3,"file":"startSparqlEndpoint.js","sourceRoot":"","sources":["../startSparqlEndpoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpServiceSparqlEndpoint, IHttpServiceSparqlEndpointArgs } from '@comunica/actor-init-query';\nimport {trainComunicaModel} from './run_comunica_experience_replay';\nimport * as cluster from 'cluster';\nimport type { Writable } from 'stream';\nimport * as path from 'path'\nimport { IBatchedTrainingExamples, ITrainingExample } from '@comunica/types';\n\n\nconst defaultConfigPath = path.join(__dirname, \"../../../comunica-rl-updated/engines/query-sparql-file/bin/\")+\"../config/config-default.json\";\nconst moduleRootPath = path.join(__dirname, \"../../../comunica-rl-updated/engines/query-sparql-file/bin/\")+\"../\";\nconst runningMomentsFeatureFile = \"../../actor-rdf-join-inner-multi-reinforcement-learning-tree/model/moments/\"+\"runningMomentsFeatures\"+1+\".json\";\nconst batchedTrainExamples: IBatchedTrainingExamples = {trainingExamples: new Map<string, ITrainingExample>, leafFeatures: {hiddenStates: [], memoryCell:[]}};\n\n// Need to pass to SPARQL endpoint context: \n// {runningMomentsFeatureFile, timeout, invalidateCacheBeforeQuery, sources, train:true, batchedTrainExamples (NEEDS TO BE REUSED IN TRAINING)}\n\nexport function createEndPoint(stdout: Writable, stderr: Writable, exit: (code: number) => void){\n    const options: IHttpServiceSparqlEndpointArgs = {moduleRootPath: moduleRootPath, mainModulePath: moduleRootPath, defaultConfigPath: defaultConfigPath, \n    configPath: defaultConfigPath, \n    context: \n    {\n    sources: ['missingGenreOutput/dataset.nt'],  \n    trainEndPoint: true, \n    batchedTrainingExamples: batchedTrainExamples\n    }, \n    timeout: 5, invalidateCacheBeforeQuery: true}\n    return new Promise<void>(resolve => {\n        const endPoint = new HttpServiceSparqlEndpoint(options || {}).run(stdout, stderr)\n          .then((result)=>resolve(result))\n          .catch(error => {\n            stderr.write(error);\n            exit(1);\n            resolve(endPoint);\n          });\n          resolve(endPoint)\n    });\n    \n};\n\nfunction sleep(ms: number) {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n}\nconst doneCreating = createEndPoint(process.stdout, process.stderr, code => process.exit(code));\nif (cluster.isMaster){\n    doneCreating.then(async ()=>{\n        // Wait for the worker to create comunica, bit hacky\n        await sleep(25000); \n        console.log(\"Done!\")\n        const numSim = 1;\n        const numSimVal = 5;\n        const numExperiencePerSim = 8;\n        const nEpochs = 40;\n        const sizeBuffer = 2000;\n    \n        // Actual engine used for training\n        // const trainEngine = new trainComunicaModel(sizeBuffer);\n        // const loadingTrain = trainEngine.loadWatDivQueries('missingGenreOutput/queries', false);\n        // const loadingValidation = trainEngine.loadWatDivQueries('missingGenreOutput/queriesVal', true);\n    \n        // loadingTrain.then(async ()=>{\n        //     await loadingValidation;\n        //     let cleanedQueriesVal: string[][] = trainEngine.valQueries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\n        //     let cleanedQueries: string[][] = trainEngine.queries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\n        \n        //     for (let i = 0; i<cleanedQueries.length;i++){\n        //         cleanedQueries[i].shift();\n        //         cleanedQueriesVal[i].shift();\n        //         for(let j=0;j<cleanedQueries[i].length;j++){\n        //             cleanedQueries[i][j] = 'SELECT' + cleanedQueries[i][j];\n        //         }\n        //         for(let k=0; k<cleanedQueriesVal[i].length;k++){\n        //             cleanedQueriesVal[i][k] = 'SELECT' + cleanedQueriesVal[i][k]\n        //         }\n        //     }\n        //     await trainEngine.awaitEngine();\n            \n        //     trainEngine.engine.queryBindingsTrain(cleanedQueries, cleanedQueriesVal, 1,1,1,1, 100, batchedTrainExamples, {sources: [\"missingGenreOutput/dataset.nt\"]} );\n        // });\n    \n    });\n}\n\n// HttpServiceSparqlEndpoint.runArgsInProcess([\"missingGenreOutput/dataset.nt\"], process.stdout, process.stderr, `${__dirname}/../`, process.env, defaultConfigPath, code => process.exit(code))\n//   .catch(error => process.stderr.write(`${error.message}/n`));\nif (cluster.isMaster){\n    const numSim = 1;\n    const numSimVal = 5;\n    const numExperiencePerSim = 8;\n    const nEpochs = 40;\n    const sizeBuffer = 2000;\n\n    // Actual engine used for training\n    const trainEngine = new trainComunicaModel(sizeBuffer);\n    const loadingTrain = trainEngine.loadWatDivQueries('missingGenreOutput/queries', false);\n    const loadingValidation = trainEngine.loadWatDivQueries('missingGenreOutput/queriesVal', true);\n\n    loadingTrain.then(async ()=>{\n        await loadingValidation;\n        let cleanedQueriesVal: string[][] = trainEngine.valQueries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\n        let cleanedQueries: string[][] = trainEngine.queries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\n    \n        for (let i = 0; i<cleanedQueries.length;i++){\n            cleanedQueries[i].shift();\n            cleanedQueriesVal[i].shift();\n            for(let j=0;j<cleanedQueries[i].length;j++){\n                cleanedQueries[i][j] = 'SELECT' + cleanedQueries[i][j];\n            }\n            for(let k=0; k<cleanedQueriesVal[i].length;k++){\n                cleanedQueriesVal[i][k] = 'SELECT' + cleanedQueriesVal[i][k]\n            }\n        }\n        await trainEngine.awaitEngine();\n        \n        trainEngine.engine.queryBindingsTrain(cleanedQueries, cleanedQueriesVal, 1,1,1,1, 100, batchedTrainExamples, {sources: [\"missingGenreOutput/dataset.nt\"]} );\n    });\n}\n"]}