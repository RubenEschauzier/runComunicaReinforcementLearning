{"version":3,"file":"helper.js","sourceRoot":"","sources":["helper.ts"],"names":[],"mappings":";;;AAIA,SAAgB,oBAAoB,CAAC,iBAAmC,EAAE,QAAgB;IACtF,iBAAiB,CAAC,CAAC,IAAG,CAAC,CAAC;IACxB,MAAM,KAAK,GAAG,QAAQ,GAAG,iBAAiB,CAAC,IAAI,CAAC;IAChD,iBAAiB,CAAC,IAAI,IAAI,KAAK,GAAG,iBAAiB,CAAC,CAAC,CAAC;IACtD,MAAM,QAAQ,GAAG,QAAQ,GAAG,iBAAiB,CAAC,IAAI,CAAC;IACnD,iBAAiB,CAAC,EAAE,IAAI,KAAK,GAAG,QAAQ,CAAC;IACzC,iBAAiB,CAAC,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;AAClF,CAAC;AAPD,oDAOC;AAED,SAAgB,QAAQ,CAAC,OAAmB;IACxC,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AACzD,CAAC;AAFD,4BAEC;AAED,SAAgB,QAAQ,CAAC,GAAW;IAChC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAC5B,MAAM,GAAG,GAAa,EAAE,CAAC;IACzB,KAAK,IAAI,CAAC,GAAC,CAAC,EAAC,CAAC,GAAC,KAAK,CAAC,MAAM,EAAC,CAAC,IAAE,CAAC,EAAC;QAC/B,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACpC;IACD,OAAO,GAAG,CAAC;AACf,CAAC;AAPD,4BAOC;AAED,MAAa,gBAAgB;IAOzB;;;;;MAKE;IACF,YAAY,OAAe,EAAE,UAAkB;QAC3C,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAoC,CAAC;QACvE,IAAI,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAoC,CAAC;QACrE,IAAI,CAAC,oBAAoB,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IAC3B,CAAC;IAEM,aAAa,CAAC,QAAgB,EAAE,WAAmB;QACtD,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACpE,CAAC;IAEM,mBAAmB;QACtB,MAAM,KAAK,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAE,IAAI,CAAC,CAAC;QACvD,MAAM,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,WAAW,CAAC,EAAC;YAChD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACnB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACjB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACvC,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,OAAO,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC7C;QAED,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,WAAW,CAAE,EAAE,GAAG,CAAC,CAAC;IAClE,CAAC;IAEM,WAAW,CAAC,KAAa;QAC5B,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACnD,IAAI,CAAC,QAAQ,EAAC;YACV,OAAO,CAAC,KAAK,CAAC,uCAAuC,CAAC,CAAC;SAC1D;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IACD;;;;;;;;;;;OAWG;IACI,aAAa,CAAC,QAAgB,EAAE,WAAmB,EAAE,UAAuB,EAAE,eAAiC;QAClH,MAAM,qBAAqB,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAC9D,IAAI,CAAC,qBAAqB,EAAC;YACvB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;SAC9C;QAED,MAAM,kBAAkB,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QACrE,MAAM,gBAAgB,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC;QAE/C,qCAAqC;QACrC,MAAM,YAAY,GAAY,gBAAgB,CAAC,MAAM,IAAI,qBAAqB,CAAA;QAE9E,IAAI,kBAAkB,EAAC;YACnB;;;eAGG;YACH,IAAI,YAAY,EAAC;gBACb,6CAA6C;gBAC7C,kBAAkB,CAAC,sBAAsB,IAAI,CAAC,CAAC,UAAU,CAAC,sBAAsB,GAAG,kBAAkB,CAAC,sBAAsB,CAAC,GAAC,CAAC,kBAAkB,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;gBACxJ,kBAAkB,CAAC,CAAC,IAAI,CAAC,CAAC;gBAC1B,mEAAmE;gBACnE,kBAAkB,CAAC,uBAAuB,GAAG,CAAC,kBAAkB,CAAC,sBAAsB,GAAG,eAAe,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC,GAAG,CAAC;gBACtI,OAAO;aACV;YACD,2IAA2I;YAC3I,wCAAwC;YACxC,MAAM,qBAAqB,GAAG,kBAAkB,CAAC,sBAAsB,CAAC;YACxE,IAAI,qBAAqB,GAAG,UAAU,CAAC,sBAAsB,EAAC;gBAC1D,kBAAkB,CAAC,sBAAsB,GAAG,UAAU,CAAC,sBAAsB,CAAC;aACjF;YACD,kBAAkB,CAAC,CAAC,IAAE,CAAC,CAAA;YACvB,uIAAuI;YACvI,+GAA+G;YAC/G,kBAAkB,CAAC,uBAAuB,GAAG,CAAC,kBAAkB,CAAC,sBAAsB,GAAG,eAAe,CAAC,IAAI,CAAC,GAAC,eAAe,CAAC,GAAG,CAAC;YACpI,OAAO;SACV;QAED,4CAA4C;QAC5C,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QACrE,6CAA6C;QAC7C,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,WAAW,EAAC,CAAC,CAAC;QAE5E,gGAAgG;QAChG,IAAI,IAAI,CAAC,OAAO,EAAE,GAAC,IAAI,CAAC,OAAO,EAAC;YAC5B,MAAM,cAAc,GAAmB,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAG,CAAC;YAC1E,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,cAAc,CAAC,KAAK,CAAE,CAAC,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;SAE1F;QACD,OAAO;IACX,CAAC;IAEM,yBAAyB;IAEhC,CAAC;IAEM,oBAAoB,CAAC,QAAgB,EAAE,YAAsC;QAChF,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;QACnD,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,GAAG,EAAuB,CAAC,CAAC;IAE3E,CAAC;IAEM,gBAAgB,CAAC,QAAgB;QACpC,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,YAAY,CAAC,MAAM,CAAC;IACrE,CAAC;IAEM,OAAO;QACV,OAAO,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC;IAC5C,CAAC;IAEM,gBAAgB;QACnB,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,EAAC;YAC1D,IAAI,KAAK,CAAC,IAAI,GAAC,CAAC,EAAC;gBACb,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACjB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aACtB;SACJ;IACL,CAAC;CAEJ;AAxID,4CAwIC","sourcesContent":["import { IAggregateValues, IResultSetRepresentation, IRunningMoments } from \"@comunica/mediator-join-reinforcement-learning\";\nimport { timeStamp } from \"console\";\n\n\nexport function updateRunningMoments(toUpdateAggregate: IAggregateValues, newValue: number){\n    toUpdateAggregate.N +=1;\n    const delta = newValue - toUpdateAggregate.mean; \n    toUpdateAggregate.mean += delta / toUpdateAggregate.N;\n    const newDelta = newValue - toUpdateAggregate.mean;\n    toUpdateAggregate.M2 += delta * newDelta;\n    toUpdateAggregate.std = Math.sqrt(toUpdateAggregate.M2 / toUpdateAggregate.N);\n}\n\nexport function idxToKey(indexes: number[][]){\n    return indexes.flat().toString().replaceAll(',', '');\n}\n\nexport function keyToIdx(key: string){\n    const chars = key.split('');\n    const idx: number[][]=[];\n    for (let i=0;i<chars.length;i+=2){\n      idx.push([+chars[i], +chars[i+1]]);\n    }\n    return idx;\n}\n\nexport class ExperienceBuffer{\n\n    experienceBufferMap: Map<string,Map<string,IExperience>>;\n    queryLeafFeatures: Map<string, IResultSetRepresentation>;\n    experienceAgeTracker: IExperienceKey[];\n    maxSize: number;\n\n    /**\n     * FIFO query execution buffer. We use this for periodical training. This allows for better data efficiency since the model is incredibly light weight\n     * while query execution is the main bottleneck.\n     * @param maxSize Maximal number of experiences in buffer\n     * @param numQueries The total number of queries in the training data\n    */\n    constructor(maxSize: number, numQueries: number){\n        this.experienceBufferMap = new Map<string, Map<string, IExperience>>();\n        this.queryLeafFeatures = new Map<string, IResultSetRepresentation>();\n        this.experienceAgeTracker = [];\n        this.maxSize = maxSize;\n    }\n\n    public getExperience(queryKey: string, joinPlanKey: string){\n        return this.experienceBufferMap.get(queryKey)!.get(joinPlanKey);\n    }\n\n    public getRandomExperience(): [IExperience, IExperienceKey] {\n        const index = (Math.random() * (this.getSize()) ) << 0;\n        const key = this.experienceAgeTracker[index];\n        if (!this.getExperience(key.query, key.joinPlanKey)){\n            console.log(index);\n            console.log(key);\n            console.log(this.experienceAgeTracker);\n            this.printExperiences();\n            console.error(\"Got invalid index or key\");\n        }\n\n        return [this.getExperience(key.query, key.joinPlanKey)!, key];\n    }\n\n    public getFeatures(query: string){\n        const features = this.queryLeafFeatures.get(query);\n        if (!features){\n            console.error(\"Query requested with no leaf features\");\n        }\n        return features;\n    }\n    /**\n     * Function to set a new experience. \n     * For incomplete join plans we keep track of the best recorded execution time from the partial join plan\n     * For complete join plans we track the average execution time during training\n     * When the maximum number of experiences is reached, the buffer acts as a queue and removes the oldest experience\n     * When an already existing experience is revisted we DON'T refresh the age of the experience \n     * \n     * @param queryKey The query number of the executed query\n     * @param joinPlanKey The key representing the experienced joinplan\n     * @param experience The information obtained during query execution\n     * @returns \n     */\n    public setExperience(queryKey: string, joinPlanKey: string, experience: IExperience, runningMomentsY: IAggregateValues){\n        const fullJoinPlanKeyLength = this.getNumJoinsQuery(queryKey);\n        if (!fullJoinPlanKeyLength){\n            throw new Error(\"Uninitialised query key\");\n        }\n\n        const existingExperience = this.getExperience(queryKey, joinPlanKey);\n        const joinPlanKeyArray = keyToIdx(joinPlanKey);\n\n        // True if we have complete join plan\n        const fullJoinPlan: boolean = joinPlanKeyArray.length == fullJoinPlanKeyLength\n        \n        if (existingExperience){\n            /**\n             * Note that this function is not entirely correct, if the average execution time goes up due to chance it is not reflected in the execution time\n             *of partial join plans that use the execution time of a complete join plan. This difference should be small though.\n             */\n            if (fullJoinPlan){\n                // Update unnormalized execution time average\n                existingExperience.actualExecutionTimeRaw += ((experience.actualExecutionTimeRaw - existingExperience.actualExecutionTimeRaw)/(existingExperience.N+1));\n                existingExperience.N += 1;\n                // Update the normalized execution time using new average raw value\n                existingExperience.actualExecutionTimeNorm = (existingExperience.actualExecutionTimeRaw - runningMomentsY.mean) / runningMomentsY.std;\n                return;    \n            }\n            // If partial we update to see if the recorded raw execution time is better than previous max, we use raw because the normalized can change\n            // due to underlying statistics changing\n            const existingExecutionTime = existingExperience.actualExecutionTimeRaw;\n            if (existingExecutionTime > experience.actualExecutionTimeRaw){\n                existingExperience.actualExecutionTimeRaw = experience.actualExecutionTimeRaw;\n            }\n            existingExperience.N+=1\n            // Update the normalized execution times (At the start this can give big changes, but should be stable when num executions -> infinity)\n            // We update even if the recorded experience is worse than current, to reflect the changes in distribution of Y\n            existingExperience.actualExecutionTimeNorm = (existingExperience.actualExecutionTimeRaw - runningMomentsY.mean)/runningMomentsY.std;\n            return;\n        }\n\n        // If it doesn't exist we set new experience\n        this.experienceBufferMap.get(queryKey)!.set(joinPlanKey, experience);\n        // Add it to the 'queue' to keep track of age\n        this.experienceAgeTracker.push({query: queryKey, joinPlanKey: joinPlanKey});\n\n        // If size exceeds max from push we remove first pushed element from the age tracker and the map\n        if (this.getSize()>this.maxSize){\n            const removedElement: IExperienceKey = this.experienceAgeTracker.shift()!;\n            this.experienceBufferMap.get(removedElement.query)!.delete(removedElement.joinPlanKey);\n\n        }\n        return;\n    }\n    \n    public refreshExistingExperience(){\n\n    }\n\n    public setLeafFeaturesQuery(queryKey: string, leafFeatures: IResultSetRepresentation){\n        this.queryLeafFeatures.set(queryKey, leafFeatures);\n        this.experienceBufferMap.set(queryKey, new Map<string, IExperience>());\n\n    }\n\n    public getNumJoinsQuery(queryKey: string){\n        return this.queryLeafFeatures.get(queryKey)?.hiddenStates.length;\n    }\n\n    public getSize(){\n        return this.experienceAgeTracker.length;\n    }\n\n    public printExperiences(){\n        for (const [key, value] of this.experienceBufferMap.entries()){\n            if (value.size>0){\n                console.log(key);\n                console.log(value);\n            }\n        }\n    }\n\n}\n\nexport interface IExperience{\n    actualExecutionTimeNorm: number;\n    actualExecutionTimeRaw: number;\n    joinIndexes: number[][]\n    N: number;\n}\nexport interface IExperienceKey{\n    query: string;\n    joinPlanKey: string;\n}\n  "]}